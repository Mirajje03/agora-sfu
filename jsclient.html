<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>SFU Client with Signaling Logs</title>
  <style>
    body { font-family: "Consolas", monospace; max-width: 900px; margin: 2em auto; background: #e0e0e0; }
    .container { background: white; padding: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-radius: 8px; }
    
    input { padding: 8px; border: 1px solid #ccc; }
    button { padding: 8px 20px; background: #0056b3; color: white; border: none; cursor: pointer; }
    button:disabled { background: #999; }

    /* Log Styling */
    #logs { 
        background: #1e1e1e; color: #00ff00; 
        padding: 15px; height: 400px; overflow-y: auto; 
        margin-top:15px; border-radius: 5px; 
        font-size: 13px; line-height: 1.4;
        white-space: pre-wrap;
    }
    
    /* Remote Audio Badges */
    .badge { 
        background: #28a745; color: white; 
        padding: 8px 12px; border-radius: 20px; 
        margin: 5px; display:inline-flex; align-items: center; gap: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        animation: pop 0.3s ease-out;
    }
    @keyframes pop { from { transform: scale(0); } to { transform: scale(1); } }
</style>
</head>
<body>

<div class="container">
  <h2 style="margin-top:0">üì° Detailed Signaling Client</h2>
  
  <div style="margin-bottom: 10px;">
    <input id="wsurl" value="ws://127.0.0.1:8000" placeholder="WS URL"> 
    <input id="roomid" value="1001" size="5" placeholder="Room">
    <button id="connect">Connect</button>
  </div>

  <div id="remotes"></div>
  <div id="logs">Waiting for connection...</div>
</div>

<script>
let pc, ws, localStream;
let isProcessingServerOffer = false; 
const logsEl = document.getElementById("logs");

function log(msg) {
    const time = new Date().toLocaleTimeString().split(' ')[0]; // HH:MM:SS
    logsEl.textContent += `[${time}] ${msg}\n`;
    logsEl.scrollTop = logsEl.scrollHeight;
    console.log(`[${time}] ${msg}`);
}

document.getElementById("connect").onclick = () => {
  ws = new WebSocket(document.getElementById("wsurl").value);
  document.getElementById("connect").disabled = true;
  logsEl.textContent = ""; // Clear logs

  ws.onopen = () => { 
      log("üîµ WebSocket Connected"); 
      setupPC(); 
  };
  
  ws.onmessage = async (msg) => {
    const data = JSON.parse(msg.data);

    if (data.type === "answer") {
      // -------------------------------------------------
      // RECV ANSWER (Ack for our Join or Mic Offer)
      // -------------------------------------------------
      log("üì© [RX ANSWER] Server accepted our Offer. Handshake Complete.");
      await pc.setRemoteDescription(data);
    } 
    else if (data.type === "offer") {
      // -------------------------------------------------
      // RECV OFFER (Server sending Room Audio)
      // -------------------------------------------------
      log("üì© [RX OFFER] Server sending tracks. Locking Mic logic...");
      isProcessingServerOffer = true; // Lock to prevent collision

      await pc.setRemoteDescription(data);
      
      // Create Answer
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      
      // Send Answer
      ws.send(JSON.stringify({ type: "answer", sdp: answer.sdp }));
      log("üì§ [TX ANSWER] Sent acknowledgement to Server.");
      
      // Unlock logic after a brief safety buffer
      setTimeout(() => {
          if(isProcessingServerOffer) {
              isProcessingServerOffer = false;
              log("üîì Negotiation unlocked. Ready for Mic.");
          }
      }, 500);
    } 
    else if (data.type === "candidate") {
      if (pc.remoteDescription) await pc.addIceCandidate(data);
    }
  };
};

function setupPC() {
  pc = new RTCPeerConnection();
  
  // Phase 1: Data Channel to trigger initial Join
  pc.createDataChannel("control"); 

  // Handle Remote Audio
  pc.ontrack = (e) => {
      const id = e.track.id.substring(0,5);
      log(`üîä [TRACK] New Audio Track Received: ${id}...`);
      
      const au = document.createElement('audio');
      au.srcObject = e.streams[0];
      au.autoplay = true;
      
      const b = document.createElement('div');
      b.className = 'badge'; 
      b.innerHTML = `User ${id} <span>üîä</span>`;
      b.appendChild(au);
      document.getElementById("remotes").appendChild(b);
  };

  // Handle Outgoing Negotiation (Join or Mic)
  pc.onnegotiationneeded = async () => {
      // PREVENT GLARE: If server is talking, we shut up.
      if (isProcessingServerOffer) {
          log("‚ö†Ô∏è [SKIP] Negotiation needed, but Server is active. Deferring...");
          return;
      }

      // -------------------------------------------------
      // SEND OFFER (Join or Mic)
      // -------------------------------------------------
      log("üì§ [TX OFFER] Sending local Description (Join/Mic) to Server...");
      
      try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          ws.send(JSON.stringify({ 
              type: "offer", 
              room_id: document.getElementById("roomid").value, 
              sdp: pc.localDescription.sdp 
          }));
      } catch(err) {
          log("‚ùå Offer generation failed: " + err);
      }
  };

  pc.onconnectionstatechange = () => {
      const state = pc.connectionState;
      log(`üîÑ [STATE] PeerConnection: ${state.toUpperCase()}`);
      
      if (state === 'connected') {
          log("‚úÖ Connected. Starting Mic sequence...");
          tryAddMic(); 
      }
  };

  pc.onicecandidate = ({candidate}) => {
      if(candidate) ws.send(JSON.stringify({type:"candidate", candidate:candidate.candidate, sdpMid:candidate.sdpMid}));
  }
}

// Robust System to add Mic
async function tryAddMic() {
    if (localStream) return; // Already done

    // If Server is negotiating (Phase 2), we wait.
    if (isProcessingServerOffer) {
        log("‚è≥ Server busy. Retrying Mic in 500ms...");
        setTimeout(tryAddMic, 500);
        return;
    }

    log("üé§ Acquiring Microphone...");
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        log("‚ûï Adding Mic Track to Connection...");
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
        
        // Note: addTrack automatically triggers 'onnegotiationneeded',
        // which will send the [TX OFFER].
        
    } catch(e) { 
        log("‚ùå Mic Access Error: " + e.message); 
    }
}
</script>
</body>
</html>
